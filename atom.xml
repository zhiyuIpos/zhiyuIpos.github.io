<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-02-29T01:24:08.608Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>flapCard-翻转图书动画</title>
    <link href="http://yoursite.com/2020/02/29/flapCard-%E7%BF%BB%E8%BD%AC%E5%9B%BE%E4%B9%A6%E5%8A%A8%E7%94%BB/"/>
    <id>http://yoursite.com/2020/02/29/flapCard-%E7%BF%BB%E8%BD%AC%E5%9B%BE%E4%B9%A6%E5%8A%A8%E7%94%BB/</id>
    <published>2020-02-29T01:15:10.000Z</published>
    <updated>2020-02-29T01:24:08.608Z</updated>
    
    <content type="html"><![CDATA[<p><img src="flapcard.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;flapcard.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>JS基础知识(一)</title>
    <link href="http://yoursite.com/2020/02/28/JS-ONE/"/>
    <id>http://yoursite.com/2020/02/28/JS-ONE/</id>
    <published>2020-02-28T01:56:05.000Z</published>
    <updated>2020-02-29T01:10:09.101Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JS数据类型"><a href="#JS数据类型" class="headerlink" title="JS数据类型"></a>JS数据类型</h3><ul><li>基本数据类型:  undefined、null、boolean、number、string、symbol<br>引用数据类型: object、array、function</li><li>基本数据类型和引用类型有什么差别<ul><li>基本数据类型是直接存在变量本地的类型，（特点:按值传递）</li><li>引用类型是通过一个变量存放地址，通过地址指向内存中的对象。（特点:引用地址）</li></ul></li></ul><h3 id="检测浏览器版本有哪些方式"><a href="#检测浏览器版本有哪些方式" class="headerlink" title="检测浏览器版本有哪些方式"></a>检测浏览器版本有哪些方式</h3><ul><li>navigator.userAgent  // UA.toLowerCase().indexOf(‘chrome’)</li><li>根据window对象的成员 // ‘ActiveXObject’ in window</li></ul><h3 id="介绍JS有哪些内置对象"><a href="#介绍JS有哪些内置对象" class="headerlink" title="介绍JS有哪些内置对象"></a>介绍JS有哪些内置对象</h3><ul><li>数据封装类型对象:Object、Array、Boolean、Number、String</li></ul><ul><li>其他对象:Function、Arguments、Math、Date、RegExp、Error</li></ul><p>3.ES6新增对象:Sysbol、Map、Set、Promises、Proxy、Reflect</p><h3 id="说几条Javascript的基本规范"><a href="#说几条Javascript的基本规范" class="headerlink" title="说几条Javascript的基本规范"></a>说几条Javascript的基本规范</h3><ul><li>代码缩进，建议使用”四个空格”缩进</li><li>代码段使用花括号{}包裹</li><li>变量和函数在使用前进行声明</li><li>语句结束使用分号</li><li>以大写字母开头命名构造哈数、全大写命名常量</li><li>规范定义JSON对象、补全双括号</li></ul><h3 id="如何边写高性能Javascript"><a href="#如何边写高性能Javascript" class="headerlink" title="如何边写高性能Javascript"></a>如何边写高性能Javascript</h3><ul><li>遵循 use stricct</li><li>js脚本放在页面底部、加快渲染页面</li><li>js脚本将脚本组成打包、减少请求</li><li>使用非阻塞方式下载js脚本</li><li>尽量使用局部变量来保存全局变量</li><li>尽量减少使用闭包</li><li>缓存DOM节点的访问(JQUERY里面用的比较多,重复创建多个对象，会影响效率。用变量存起来查找的对象，链式操作)</li><li>最小化重绘(repaint) 和回流 (reflow)</li></ul><h3 id="DOM-元素e和e-getAttribute-propName-和-e-propName-有什么区别和联系"><a href="#DOM-元素e和e-getAttribute-propName-和-e-propName-有什么区别和联系" class="headerlink" title="DOM 元素e和e.getAttribute(propName) 和 e.propName 有什么区别和联系"></a>DOM 元素e和e.getAttribute(propName) 和 e.propName 有什么区别和联系</h3><ul><li>attribute不能读取布尔类型的值，可以读取自定义属性，e.propName可以读取布尔类型的值，不能读取自定义属性，可以读取html dom中的标准属性</li></ul><h3 id="offsetWidth-offsetHeight-chilentWidth-clientHeight-与-scrollWidth-scrollHeight区别"><a href="#offsetWidth-offsetHeight-chilentWidth-clientHeight-与-scrollWidth-scrollHeight区别" class="headerlink" title="offsetWidth/offsetHeight,chilentWidth/clientHeight 与 scrollWidth/scrollHeight区别"></a>offsetWidth/offsetHeight,chilentWidth/clientHeight 与 scrollWidth/scrollHeight区别</h3><blockquote><p>offsetWidth/offsetHeight  ：content + padding + border ,效果与e.getBoundingClientRect()相同<br>clientWidth/clientheight :conetnt + padding,如果有滚动条，也不包含滚动条<br>scrollWidth/scrollHeight  :content + padding + 溢出内容的尺寸</p></blockquote><h3 id="描述浏览器的渲染过程，DOM树和渲染树的区别"><a href="#描述浏览器的渲染过程，DOM树和渲染树的区别" class="headerlink" title="描述浏览器的渲染过程，DOM树和渲染树的区别"></a>描述浏览器的渲染过程，DOM树和渲染树的区别</h3><ul><li>浏览器的渲染过程<ul><li>解析HTML构建DOM(DOM树),并行请求css/img/js<ul><li>css文件下载完成之后，开始构建CSSOM(csss树)</li><li>CSSOM构建结束之后,和DOM一起生成Render Tree(渲染树)</li><li>布局(layout):计算出每个节点在屏幕上的位置</li><li>显示(Painting):通过显卡把页面画到屏幕上</li></ul></li></ul></li></ul><hr><ul><li>DOM树和渲染树的区别:<ul><li>DOM树与HTML标签一一对应，包括head和隐藏元素</li><li>渲染树不包括head和隐藏元素，打算文本的每一行都是独立节点，每个节点都有对应的css属性</li></ul></li></ul><h3 id="重绘和回流-重排-的区别和关系"><a href="#重绘和回流-重排-的区别和关系" class="headerlink" title="重绘和回流(重排)的区别和关系?"></a>重绘和回流(重排)的区别和关系?</h3><ul><li>重绘: 当前渲染树种的元素外观(如:颜色)发生改变时，不影响页面布局时，产生重绘</li><li>回流: 当渲染树中的元素的布局(如:尺寸、位置…)发生改变时，产生回流重排</li><li>注意: JS获取Layout属性值(如:offsetLeft、scrollTop…)也会引起回流</li><li>回流必将引起重绘，而重绘不一样会引起回流</li></ul><h3 id="如何最小化的减少重绘和回流"><a href="#如何最小化的减少重绘和回流" class="headerlink" title="如何最小化的减少重绘和回流?"></a>如何最小化的减少重绘和回流?</h3><ul><li>需要对元素进行复制操作时,可以先隐藏(display:none)，操作完成之后再显示</li><li>需要创建多个dom节点时，使用DocumentFragement创建完成后一次性的加入document</li><li>尽量避免使用table布局，因为他会重新读取内存，然后一次性渲染到页面上</li><li>css属性简写</li><li>避免使用css表达式，每次重新调用都会重新计算值<blockquote><p>background-color:expression((new Date().getHours()%2 ?”#B8D4FF”:”#F08A00”))</p></blockquote></li></ul><h3 id="script的位置是否会影响首屏显示时间"><a href="#script的位置是否会影响首屏显示时间" class="headerlink" title="script的位置是否会影响首屏显示时间"></a>script的位置是否会影响首屏显示时间</h3><ul><li>在解析HTML生成DOM过程中,js文件的下载并行的，不需要处理到script节点，因此script的位置不影响首屏显示时间</li><li>浏览器解析HTML是自上而下的线性过程，script作为HTML的一部分统一遵循这个原则</li><li>script会延迟DomContentLoad，只显示其上部分首屏内容，从而显示首屏显示的完成时间</li></ul><h3 id="解释JavaScript中的变量提升"><a href="#解释JavaScript中的变量提升" class="headerlink" title="解释JavaScript中的变量提升"></a>解释JavaScript中的变量提升</h3><ul><li>函数声明 和通过var声明的遍历经常被Javascript引擎隐式地提升到当前作用域的顶部</li><li>声明语句中的赋值部分不会被提升，只有名称被提升</li><li>函数声明优先于变量，如果变量名和函数名相同且未赋值，则函数声明覆盖变量声明</li><li>如果函数有多个同名参数，那么最后一个参数会覆盖前面同名的参数</li></ul><h3 id="介绍JavaScript的原型-原型链-有什么特点"><a href="#介绍JavaScript的原型-原型链-有什么特点" class="headerlink" title="介绍JavaScript的原型,原型链?有什么特点?"></a>介绍JavaScript的原型,原型链?有什么特点?</h3><ul><li><strong>原型:</strong><ul><li>JavaScript所有对象都有一个<strong>proto</strong>内部属性，这个属性对应的对象的原型</li><li>函数对象除了原型之外，还有prototype属性</li><li>当函数对象作为构造函数创建实例时，该prototype属性将被作为实例对象的原型</li></ul></li><li><strong>原型链:</strong><ul><li>当一个对象调用的属性/方法自身不存在时，就回去自己的原型对象上查找</li><li>如果没找到，就去当前<strong>proto</strong>的上一辈的<strong>proto</strong>上找，直到找到属性/方法或undefined为止</li></ul></li><li><strong>原型特点:</strong><ul><li>JavaScript对象是通过引用来传递的，当修改原型时，与之相关的对象也会继承这一改变</li></ul></li></ul><h3 id="你对面向对象的理解"><a href="#你对面向对象的理解" class="headerlink" title="你对面向对象的理解"></a>你对面向对象的理解</h3><ul><li>面向对象 : 封装、继承、多态(重写)<ul><li><strong>封装</strong><ul><li>封装是什么:创建一个对象结构，集中保存一个事物的属性和功能</li><li>为什么要使用封装:便于大量数据的维护和使用</li><li>何时使用封装:只要使用面向对象的方式变成，都要先创建对象，保存所需的数据和功能，然后按需调用对象中的成员</li><li>如何实现<blockquote><p>var obj={<br>&nbsp;&nbsp;xx:xx,<br>&nbsp;&nbsp;fun(){<br>&nbsp;&nbsp;xxx<br>&nbsp;&nbsp;}<br>}</p></blockquote></li></ul></li><li><strong>继承</strong><ul><li>继承是什么:父对象中的成员，子对象无需重复创建，就可直接使用</li><li>为什么要使用继承:代码重用，节约内存</li><li>何时使用继承:js中的继承都是通过原型对象来实现</li><li>继承如何实现<ul><li>通过new一个构造函数创建</li><li>es6通过new 一个钩子函数创建</li></ul></li></ul></li><li><strong>多态</strong><ul><li>什么是多态:一个函数在不同情况下表现出来的不同的状态</li><li>包括:重载和重写</li><li>重写<ul><li>什么是重写:在子对象中定义和父对象中成员同名的自由成员</li><li>为什么:从父对象继承来的东西不总是好用的</li><li>何时:只要从父对象继承来的不好用！就可以在子对象本地重写同名成员</li><li>如何:在子对象里添加和父对象同名的自有成员即可<h3 id="JavaScript如何实现一个类，怎么实例化这个类"><a href="#JavaScript如何实现一个类，怎么实例化这个类" class="headerlink" title="JavaScript如何实现一个类，怎么实例化这个类?"></a>JavaScript如何实现一个类，怎么实例化这个类?</h3></li></ul></li></ul></li></ul></li><li>构造函数（new xx）<blockquote><p>  function Point(x,y){<br>&nbsp;&nbsp;&nbsp;this.x = x<br>&nbsp;&nbsp;&nbsp;this.y = y<br>  }<br>  Point.prototype.toString=function(){<br>&nbsp;&nbsp;&nbsp;&nbsp;return <code>${this.x}:${this.y}</code><br>}<br>var point = new Point(2,3)</p></blockquote></li><li>ES6语法糖 class 用new关键字生成实例对象<blockquote><p>class Point{<br>  constructor(x,y){<br>&nbsp;&nbsp;&nbsp;this.x = x<br>&nbsp;&nbsp;&nbsp;this.y = y<br>&nbsp;}<br>  toString(){<br>&nbsp;&nbsp;&nbsp;return <code>${this.x}:${this.y}</code><br>&nbsp;}<br>}<br>var point = new Point(2,3)</p></blockquote></li></ul><h3 id="JavaScript如何实现继承"><a href="#JavaScript如何实现继承" class="headerlink" title="JavaScript如何实现继承"></a>JavaScript如何实现继承</h3><ul><li>构造函数 使用call,apply方法，将父对象的构造函数绑定到子对象上<blockquote><p>function Cat(name,color){<br>&nbsp;Aimal.apply(this,arguments)<br>&nbsp;this.name =  name<br>&nbsp;this.color=color<br>}</p></blockquote></li><li>实例继承，将子对象的prototype指向父对象的一个实例<blockquote><p>Cat.prototype = new Animal()<br>Cat.prototype.constructor = Cat</p></blockquote></li><li>拷贝继承:把父对象所有属性和方法，拷贝进对象 </li><li>ES6语法糖 extends </li></ul><h3 id="对象的创建方式"><a href="#对象的创建方式" class="headerlink" title="对象的创建方式"></a>对象的创建方式</h3><blockquote><p>var  obj={}<br>var obj = new Object()<br>var obj = new new Student(xx)构造函数创建一个对象</p></blockquote><hr><h3 id="谈谈this对象的理解"><a href="#谈谈this对象的理解" class="headerlink" title="谈谈this对象的理解"></a>谈谈this对象的理解</h3><ul><li>this总是指向函数的调用者</li><li>如果有new 关键字，this指向new出来的实例对象</li><li>在事件中，this指向触发这个事件的对象</li><li>IE下 attacchEvent中的this总是指向全局对象window</li></ul><h3 id="浏览器兼容性问题"><a href="#浏览器兼容性问题" class="headerlink" title="浏览器兼容性问题:"></a>浏览器兼容性问题:</h3><ul><li><p>事件绑定:onclick=function(){}(dom 0 级)</p></li><li><p>DOM: elem.addEventListener(“click”,function(){},false/true)</p><ul><li>外向内:捕获</li><li>目标触发</li><li>内向外:冒泡</li></ul></li><li><p>IE8:btn.attachEvent(‘onclick’,function(){})</p><ul><li>目标触发</li><li>内向外:冒泡</li></ul></li><li><p>获得事件对象的方法</p><ul><li>DOM:elem.addEventListener(‘click’,function(e){e-&gt;event})</li><li>IE8:elem.addattachEvent(‘click’,function(){var e=window.event})</li></ul></li><li><p>获得目标元素</p><ul><li>DOM: e.target</li><li>IE8: e.srcElement</li></ul></li><li><p>阻止冒泡</p><ul><li>DOM：e.stopPropagetion()</li><li>IE8: e.cancelBubble = true</li></ul></li><li><p>阻止默认行为</p><ul><li>DOM: e.preventDefault()</li><li>IE8: 事件处理函数中:e.returnValue =false</li></ul></li><li><p>移除事件</p><ul><li>DOM: e.removeEventListener(‘click’,handle,false)</li><li>e.detachEvent(event,handle) </li></ul></li><li><p>定义一个函数，可以支持所有处理函数的绑定</p><blockquote><p>function bindEvent(elem,type,handle){<br>&nbsp;&nbsp; //判断当前的的attachEvent是否是一个方法，如果是表示运行在IE8中，如果不是表示运行在其他浏览器中<br>&nbsp;&nbsp;if(elem.attachEvent !== ‘function’){<br> &nbsp;&nbsp;&nbsp;&nbsp;elem.addEventListener(type,handle)<br> &nbsp;&nbsp;}else{<br> &nbsp;&nbsp;&nbsp;&nbsp;//因为在attach中的this指向的是window，所以要绑定为当前的elem这个对象<br> &nbsp; &nbsp;&nbsp;elem.attachEvent(‘on’+type,function(){<br> &nbsp;&nbsp;&nbsp;&nbsp;let e = window.event<br> &nbsp;&nbsp;&nbsp;&nbsp;e.target = e.srcElement<br> &nbsp;&nbsp;&nbsp;&nbsp;//临时绑定this为当前的elem<br> &nbsp;&nbsp;&nbsp;&nbsp;handle(e).call(this,e)<br> &nbsp; &nbsp;&nbsp;})<br>}<br>}<br>handle(btn,’click’,function(e){xxx})</p></blockquote></li></ul><h3 id="如何获得有一个DOM元素的绝对位置"><a href="#如何获得有一个DOM元素的绝对位置" class="headerlink" title="如何获得有一个DOM元素的绝对位置"></a>如何获得有一个DOM元素的绝对位置</h3><ul><li>elem.offsetLeft // 距离父元素左侧的位置</li><li>elem.offsetTop //距离父元素顶部的距离</li><li>elem.getBoundingClientRect() //返回DOMRect对象，包含一组描述边框的只读属性，单位为像素</li></ul><h3 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h3><ul><li>防抖:就是在规定时间内，只触发一次事件，如果未在规定时间内再次触发，则重新开始计算时间，直到规定时间满才触发事件，发送请求<blockquote><p>var timer;<br>window.onscroll=function(){<br>//第一次滚动的时候，timer是为undefined的，所以它会执行发送请求的操作，但是如果在200ms之内它又滚动了，就会重新进来判断，此时的timer是有值的了，所以会清空掉，重新执行发送请求的代码</p><p>&nbsp;&nbsp;if(timer!==undefined){<br>&nbsp;&nbsp;&nbsp;clearTimeout(timer)<br>&nbsp;&nbsp;}<br>&nbsp;timer = setTimeout(function(){<br>&nbsp;console.log(“发送请求啦”)<br>&nbsp;},200)<br>}</p></blockquote></li></ul><ul><li>节流:在上一个请求完成之后才触发下一个请求<blockquote><p>var canClick = true//开关变量<br>btn.click=function(){<br> &nbsp;&nbsp;if(canClick){<br>&nbsp;&nbsp;&nbsp;canClick=false //关开关<br>&nbsp;&nbsp;&nbsp;setTimeout(function(){<br> &nbsp;&nbsp;&nbsp;&nbsp;console.log(“请求完成”)<br>&nbsp;&nbsp;&nbsp;&nbsp;canClick= true //打开开关<br>&nbsp;&nbsp;&nbsp;})<br>&nbsp;&nbsp;}<br>}</p></blockquote></li></ul><h3 id="分析-‘1’-’2’-’3’-map-parseInt"><a href="#分析-‘1’-’2’-’3’-map-parseInt" class="headerlink" title="分析[‘1’,’2’,’3’].map(parseInt)"></a>分析[‘1’,’2’,’3’].map(parseInt)</h3><p>答案:[1,NaN,NaN]</p><ul><li>parseInt(string,radix) //表示进制数</li></ul><h3 id="new操作符具体干了什么"><a href="#new操作符具体干了什么" class="headerlink" title="new操作符具体干了什么"></a>new操作符具体干了什么</h3><ul><li>创建实例对象，this变量引用该地址，同时还继承了构造函数的原型</li><li>属性和方法被加入到this应用对象中</li><li>新创建的对象由this所引用，并且最后隐式的返回this</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;JS数据类型&quot;&gt;&lt;a href=&quot;#JS数据类型&quot; class=&quot;headerlink&quot; title=&quot;JS数据类型&quot;&gt;&lt;/a&gt;JS数据类型&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;基本数据类型:  undefined、null、boolean、number、string、sy
      
    
    </summary>
    
    
    
      <category term="css js" scheme="http://yoursite.com/tags/css-js/"/>
    
  </entry>
  
  <entry>
    <title>第一篇文章</title>
    <link href="http://yoursite.com/2020/02/25/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
    <id>http://yoursite.com/2020/02/25/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</id>
    <published>2020-02-25T13:25:27.000Z</published>
    <updated>2020-02-27T12:22:26.605Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
      <category term="zhiyuIpos" scheme="http://yoursite.com/tags/zhiyuIpos/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2020/02/25/hello-world/"/>
    <id>http://yoursite.com/2020/02/25/hello-world/</id>
    <published>2020-02-25T12:50:31.228Z</published>
    <updated>2020-02-25T12:50:31.229Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
